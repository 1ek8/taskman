This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
gradle/
  wrapper/
    gradle-wrapper.properties
src/
  main/
    java/
      com/
        aniket/
          taskman/
            config/
              MapperConfig.java
              WebSecurityConfig.java
            controller/
              StudentController.java
            dto/
              AddStudentDTO.java
              StudentDTO.java
            entity/
              Student.java
            repository/
              StudentRepository.java
            service/
              impl/
                StudentServiceImpl.java
              StudentService.java
            PaymentService.java
            RazorpayPaymentService.java
            StripePaymentService.java
            TaskManApplication.java
    resources/
      application.properties
      data.sql
  test/
    java/
      com/
        aniket/
          taskman/
            StudentTest.java
            TaskManApplicationTests.java
build.gradle
settings.gradle
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/main/java/com/aniket/taskman/config/WebSecurityConfig.java">
//package com.aniket.taskman.config;
//
//import org.springframework.context.annotation.Bean;
//import org.springframework.context.annotation.Configuration;
//import org.springframework.security.config.Customizer;
//import org.springframework.security.config.annotation.web.builders.HttpSecurity;
//import org.springframework.security.web.SecurityFilterChain;
//
//@Configuration
//public class WebSecurityConfig {
//
//    @Bean
//    public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity){
//        httpSecurity.formLogin(Customizer.withDefaults());
//    }
//}
</file>

<file path="src/main/resources/data.sql">
INSERT INTO student_table (student_table_name, email) VALUES
('borat', 'borat@kazak.com'),
('smoke', 'michael@sinners.com');
</file>

<file path="gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-9.2.1-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="src/main/java/com/aniket/taskman/config/MapperConfig.java">
package com.aniket.taskman.config;

import org.modelmapper.ModelMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MapperConfig {

    @Bean
    public ModelMapper modelMapper(){
        return new ModelMapper();
    }

}
</file>

<file path="src/main/java/com/aniket/taskman/repository/StudentRepository.java">
package com.aniket.taskman.repository;


import com.aniket.taskman.entity.Student;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface StudentRepository extends JpaRepository<Student, Long> {

    Student findByName(String name);

    List<Student> findByNameOrEmail(String name, String email);
}
</file>

<file path="src/main/java/com/aniket/taskman/PaymentService.java">
package com.aniket.taskman;

public interface PaymentService {
    String pay();
}
</file>

<file path="src/main/java/com/aniket/taskman/RazorpayPaymentService.java">
package com.aniket.taskman;

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;

@Component
@ConditionalOnProperty(name="payment.provider", havingValue = "razorpay")
public class RazorpayPaymentService implements PaymentService {

    @Override
    public String pay(){
        String Payment = "Razorpay Payment failed";
        System.out.println("Payment from : " + Payment);
        return Payment;
    }

}
</file>

<file path="src/main/java/com/aniket/taskman/StripePaymentService.java">
package com.aniket.taskman;

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;
//import org.springframework.stereotype.Controller;
//import org.springframework.stereotype.Repository;
//import org.springframework.stereotype.Service;
//import org.springframework.web.bind.annotation.RestController;

//@Service
//@RestController
//@Repository
//@Controller
@Component
@ConditionalOnProperty(name="payment.provider", havingValue = "stripe")
public class StripePaymentService implements PaymentService{

    @Override
    public String pay() {
        String Payment = "Stripe Payment";
        System.out.println("Payment from : " + Payment);
        return "";
    }
}
</file>

<file path="src/main/java/com/aniket/taskman/TaskManApplication.java">
package com.aniket.taskman;

//import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class TaskManApplication implements CommandLineRunner {

    public static void main(String[] args) {
		SpringApplication.run(TaskManApplication.class, args);
	}

//    @Autowired
    private PaymentService paymentService ; //this can be final too, @AutoWired not used

    public TaskManApplication(PaymentService paymentService) {
        this.paymentService = paymentService;
    }

    @Override
    public void run(String... args) throws Exception {
        String Payment = paymentService.pay();
        System.out.println("Payment Done : " + Payment);
    }
}
</file>

<file path="src/test/java/com/aniket/taskman/StudentTest.java">
package com.aniket.taskman;

import com.aniket.taskman.entity.Student;
import com.aniket.taskman.repository.StudentRepository;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@SpringBootTest
public class StudentTest {

    @Autowired
    private StudentRepository studentRepository;

    @Test
    public void testStudentRepository() {
        List<Student> studentList = studentRepository.findAll();
        System.out.println(studentList);
    }

    @Test
    @Transactional //when not added, db calls are treated as individuals. this annotation clubs together all the calls and treats them all as a single unit
    public void testGetStudentbyId(){

        Long id = 1L;
        Student s1 = studentRepository.findById(id).orElseThrow();

        Student s2 = studentRepository.findById(id).orElseThrow();

        s1.setName("yoo"); //this name is updated without save action because this name gets saved in the persistent state and that state ends up being shipped along with the rest without rollback

//        studentRepository.save(s1);

    }

    @Test
    public void testDerivedQuery() {

        Student student = studentRepository.findByName("smoke");
        List<Student> studentList= studentRepository.findByNameOrEmail("smoke", "borat@kazak.com");
        System.out.println(student);
        System.out.println(studentList);
    }

}
</file>

<file path="src/test/java/com/aniket/taskman/TaskManApplicationTests.java">
package com.aniket.taskman;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class TaskManApplicationTests {

	@Test
	void contextLoads() {
	}

}
</file>

<file path="settings.gradle">
plugins {
    id 'org.gradle.toolchains.foojay-resolver-convention' version '1.0.0'
}

rootProject.name = 'taskman'
</file>

<file path="src/main/java/com/aniket/taskman/dto/AddStudentDTO.java">
package com.aniket.taskman.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class AddStudentDTO {

    @NotBlank(message="name field is required")
    @Size(min = 3, max = 20, message = "length of name should be between 3 to 20 characters")
    public String name;

    @Email
    @NotBlank(message="email field is required")
    public String email;
}
</file>

<file path="src/main/java/com/aniket/taskman/dto/StudentDTO.java">
package com.aniket.taskman.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data //creates boilerplate for getter-setter, constructor, others
@AllArgsConstructor
@NoArgsConstructor
public class StudentDTO {
    private Long id;
    private String name;
    private String email;

}
</file>

<file path="src/main/resources/application.properties">
spring.application.name=TaskMan

payment.provider = stripe
#Port configuration
server.port=8080

#DB configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/postgres
spring.datasource.username=postgres
spring.datasource.password=mysecretpassword

spring.jpa.hibernate.ddl-auto=create
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

spring.jpa.defer-datasource-initialization=update
spring.sql.init.mode=always
spring.sql.init.data-locations=classpath:data.sql

debug=false

#security config
spring.security.user.name=aniket
spring.security.user.password=anikate
</file>

<file path="src/main/java/com/aniket/taskman/entity/Student.java">
package com.aniket.taskman.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@Entity
@Getter
@Setter
@ToString
@Table(
        name = "student_table",
        uniqueConstraints = {
                @UniqueConstraint(name = "unique_student_email", columnNames = {"email"}) //now two students with same email cannot coexist in this table, uniqueConstratints bring down get queries' speed so need to be planned strategically
        },
        indexes = {
                @Index(name = "idx_student_email", columnList = "email") // makes fetch queries faster by creating an index (extra memory)
        }
)
public class Student {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name="student_table_name", nullable = false)
    private String name;

    @ToString.Exclude
    private String email;

}
</file>

<file path="src/main/java/com/aniket/taskman/service/impl/StudentServiceImpl.java">
package com.aniket.taskman.service.impl;

import com.aniket.taskman.dto.AddStudentDTO;
import com.aniket.taskman.dto.StudentDTO;
import com.aniket.taskman.entity.Student;
import com.aniket.taskman.repository.StudentRepository;
import com.aniket.taskman.service.StudentService;
import lombok.RequiredArgsConstructor;
import org.modelmapper.ModelMapper;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;

@Service
@RequiredArgsConstructor //don't need to make a constructor for all variables declared as final
public class StudentServiceImpl implements StudentService {

    private final StudentRepository studentRepository;
    private final ModelMapper modelMapper;

    @Override
    public List<StudentDTO> getAllStudents() {
        List<Student> students = studentRepository.findAll();
        return students
                .stream()
//                .map(student -> new StudentDTO(student.getId(), student.getName(), student.getEmail()))
                .map(student -> modelMapper.map(student, StudentDTO.class))
                .toList();
    }

    @Override
    public StudentDTO getStudentbyId(Long id) {
        Student student = studentRepository.findById(id).orElseThrow(() -> new IllegalArgumentException("Student not Found for given id"));
        StudentDTO studentDto = modelMapper.map(student, StudentDTO.class);
        return studentDto;
    }

    @Override
    public AddStudentDTO createNewStudent(AddStudentDTO addStudentDTO) {
        Student newStudent = modelMapper.map(addStudentDTO, Student.class);
        Student student = studentRepository.save(newStudent);
        return modelMapper.map(student, AddStudentDTO.class);
    }

    @Override
    public void deleteStudentbyId(Long id) {
        if(!studentRepository.existsById(id)) {
            throw new IllegalArgumentException("Student with " + id + " as ID doesn't seem to exist in DB");
        }
        studentRepository.deleteById(id);
    }

    @Override
    public StudentDTO updateStudent(Long id, AddStudentDTO addStudentDTO) {
        Student student = studentRepository.findById(id).orElseThrow( () -> new IllegalArgumentException("Student with ID: " + id + "not found in DB"));
        modelMapper.map(addStudentDTO, student);
        student = studentRepository.save(student);
        return modelMapper.map(student, StudentDTO.class);
    }

    @Override
    public StudentDTO updatePartialStudent(Long id, Map<String, Object> updates) {
        Student student = studentRepository.findById(id).orElseThrow( () -> new IllegalArgumentException("Student with ID: " + id + "not found in DB"));
        updates.forEach((field, value) -> {
           switch (field){
               case "name" :
                   student.setName((String) value);
                   break;
               case "email" :
                   student.setEmail((String) value);
                   break;
               default: throw new IllegalArgumentException("Field not supported");
           }
        });

        Student savedStudent = studentRepository.save(student);
        return modelMapper.map(savedStudent, StudentDTO.class);
    }
}
</file>

<file path="src/main/java/com/aniket/taskman/service/StudentService.java">
package com.aniket.taskman.service;

import com.aniket.taskman.dto.AddStudentDTO;
import com.aniket.taskman.dto.StudentDTO;
import org.jspecify.annotations.Nullable;
//import com.aniket.taskman.entity.Student;

import java.util.List;
import java.util.Map;

public interface StudentService {

    List<StudentDTO> getAllStudents();

    StudentDTO getStudentbyId(Long id);

    AddStudentDTO createNewStudent(AddStudentDTO addStudentDTO);

    void deleteStudentbyId(Long id);

    StudentDTO updateStudent(Long id, AddStudentDTO addStudentDTO);

    StudentDTO updatePartialStudent(Long id, Map<String, Object> updates);
}
</file>

<file path="build.gradle">
plugins {
	id 'java'
	id 'org.springframework.boot' version '4.0.0'
	id 'io.spring.dependency-management' version '1.1.7'
}

group = 'com.aniket'
version = '0.0.1-SNAPSHOT'
description = 'Demo project for Spring Boot'

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(21)
	}
}

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}

repositories {
	mavenCentral()
}

dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-webmvc'
    implementation 'org.modelmapper:modelmapper:3.1.0'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    runtimeOnly 'org.postgresql:postgresql'
    compileOnly 'org.projectlombok:lombok'
	developmentOnly 'org.springframework.boot:spring-boot-devtools'
	annotationProcessor 'org.projectlombok:lombok'
	testImplementation 'org.springframework.boot:spring-boot-starter-webmvc-test'
    testImplementation 'org.springframework.boot:spring-boot-starter-data-jpa-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    testImplementation 'org.springframework.boot:spring-boot-starter-validation-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    testImplementation 'org.springframework.boot:spring-boot-starter-security-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

tasks.named('test') {
	useJUnitPlatform()
}
</file>

<file path="src/main/java/com/aniket/taskman/controller/StudentController.java">
package com.aniket.taskman.controller;

import com.aniket.taskman.dto.AddStudentDTO;
import com.aniket.taskman.dto.StudentDTO;
//import com.aniket.taskman.entity.Student;
//import com.aniket.taskman.repository.StudentRepository;
import com.aniket.taskman.service.StudentService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.modelmapper.ModelMapper;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequiredArgsConstructor
public class StudentController {

    private final StudentService studentService;

//    public StudentController(StudentService studentService) {
//        this.studentService = studentService;
//    }

    @GetMapping("/student")
    public ResponseEntity<List<StudentDTO>> getStudent() {
        return ResponseEntity.status(HttpStatus.OK).body(studentService.getAllStudents());
    }

    @GetMapping("/student/{id}")
    public ResponseEntity<StudentDTO> getStudentById(@PathVariable Long id) {
//        return new StudentDTO(59L, "Aniket", "aniketsingh2151@gmail.com");
        return ResponseEntity.status(HttpStatus.OK).body(studentService.getStudentbyId(id));
    }

    @PostMapping("/student")
    public ResponseEntity<AddStudentDTO> createNewStudent(@RequestBody @Valid AddStudentDTO addStudentDTO) {
        return ResponseEntity.status(HttpStatus.CREATED).body(studentService.createNewStudent(addStudentDTO));
    }

    @DeleteMapping("/student/{id}")
    public ResponseEntity<Void> deleteOneStudent(@PathVariable Long id) {
        studentService.deleteStudentbyId(id);
        return ResponseEntity.noContent().build();
    }

    @PutMapping("/student/{id}")
    public ResponseEntity<StudentDTO> updateStudent(@PathVariable Long id,
                                                    @RequestBody @Valid AddStudentDTO addStudentDTO) {
        return ResponseEntity.status(HttpStatus.OK).body(studentService.updateStudent(id, addStudentDTO));
    }

    @PatchMapping("/student/{id}")
    public ResponseEntity<StudentDTO> updatePartialStudent(@PathVariable Long id,
                                                           @RequestBody Map<String, Object> updates) {
        return ResponseEntity.status(HttpStatus.OK).body(studentService.updatePartialStudent(id, updates));
    }
}
</file>

</files>
